//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(unused)]
#![allow(clippy::useless_format)]
#![allow(non_camel_case_types)]
use crate::documentation::Documented;
use crate::error::CustomErrorMessage;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use crate::error::NamedError;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilEnvironment {
    #[doc = "# Summary "]
    #[doc = "Invalid command line arguments provided."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "There are missing or invalid command line arguments, or an invalid combination of arguments is provided."]
    InvalidArguments {
        details: String,
        arguments: String,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Failed to start the server and bind it to the requested host and port."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync starts the server and listens to requests on a specified host and port, 0.0.0.0:8011 by default. They are configurable using `--host` and `--port` command line arguments."]
    #[doc = ""]
    #[doc = "The host and port used by anvil-zksync are also displayed when you start anvil-zksync:"]
    #[doc = ""]
    #[doc = "```text"]
    #[doc = "========================================"]
    #[doc = "Listening on 0.0.0.0:8011"]
    #[doc = "========================================"]
    #[doc = "```"]
    #[doc = ""]
    #[doc = "This error indicates that listening on the specified host and port failed."]
    ServerStartupFailed {
        host_requested: String,
        port_requested: u32,
        details: String,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Unable to access log file."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync was unable to open log file for writing."]
    #[doc = "By default, the log file is searched for at `./anvil-zksync.log`."]
    #[doc = "You may provide this path explicitly through the CLI argument `--log-file-path`."]
    LogFileAccessFailed {
        log_file_path: String,
        wrapped_error: String,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Unable to append to log file. Details: {wrapped_error}"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync was unable to write logs to the selected file."]
    #[doc = "By default, the log file is searched for at `./anvil-zksync.log`."]
    #[doc = "You may provide this path explicitly through the CLI argument `--log-file-path`."]
    LogFileWriteFailed {
        log_filename: String,
        wrapped_error: String,
    } = 11u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for AnvilEnvironment {}
impl NamedError for AnvilEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilEnvironment> for crate::ZksyncError {
    fn from(val: AnvilEnvironment) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for AnvilEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilEnvironment::GenericError { message }
    }
}
impl From<AnvilEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilEnvironment> for crate::serialized::SerializedError {
    fn from(value: AnvilEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilEnvironment {
    fn get_message(&self) -> String {
        match self {
            AnvilEnvironment::InvalidArguments { details, arguments } => {
                format!("[anvil_zksync-env-1] Invalid arguments: {details}.")
            }
            AnvilEnvironment::ServerStartupFailed {
                host_requested,
                port_requested,
                details,
            } => {
                format ! ("[anvil_zksync-env-2] Failed to start server at {host_requested}:{port_requested}: {details}.")
            }
            AnvilEnvironment::LogFileAccessFailed {
                log_file_path,
                wrapped_error,
            } => {
                format ! ("[anvil_zksync-env-10] Unable to access log file: {log_file_path}. Details: {wrapped_error}")
            }
            AnvilEnvironment::LogFileWriteFailed {
                log_filename,
                wrapped_error,
            } => {
                format ! ("[anvil_zksync-env-11] Unable to append more lines to the log file `{log_filename}`: {wrapped_error}")
            }
            AnvilEnvironment::GenericError { message } => {
                format!("[anvil_zksync-env-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilGenericCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilGeneric {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for AnvilGeneric {}
impl NamedError for AnvilGeneric {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilGenericCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilGeneric> for crate::ZksyncError {
    fn from(val: AnvilGeneric) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilGeneric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for AnvilGeneric {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilGeneric {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilGeneric::GenericError { message }
    }
}
impl From<AnvilGeneric> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilGeneric) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilGeneric> for crate::serialized::SerializedError {
    fn from(value: AnvilGeneric) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilGeneric {
    fn get_message(&self) -> String {
        match self {
            AnvilGeneric::GenericError { message } => {
                format!("[anvil_zksync-gen-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilNodeCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilNode {
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverted and gas was burned."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction execution is reverted due to an error in the anvil-zksync virtual machine execution and all gas is burned."]
    #[doc = "This is a wrapper error that contains a more specific error inside it."]
    #[doc = ""]
    #[doc = "The VM may fail for various reasons including:"]
    #[doc = "- Account validation failures (signature issues, nonce mismatches)"]
    #[doc = "- Paymaster-related errors (when testing account abstraction features)"]
    #[doc = "- Gas limit exceedance"]
    #[doc = "- Storage access limitations"]
    #[doc = "- Contract execution failures"]
    #[doc = ""]
    #[doc = "When using anvil-zksync for testing, these failures are valuable signals that help you identify issues with your contracts or transactions before deploying to the real ZKSync network."]
    TransactionHalt {
        inner: Box<Halt>,
        transaction_hash: Box<zksync_basic_types::H256>,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction validation is failed and it is not executed."]
    #[doc = "This is a wrapper error that contains a more specific validation error inside it, which provides details about the cause of failure."]
    #[doc = ""]
    #[doc = "The validation may fail for various reasons including:"]
    #[doc = "- Gas limit exceedance"]
    #[doc = "- Invalid gas limit value"]
    #[doc = "- maxFeePerGas exceeding maxPriorityFeePerGas, and so on."]
    #[doc = ""]
    #[doc = "When using anvil-zksync for testing, these errors are valuable signals that help you identify issues with your contracts or transactions before deploying to the real ZKSync network."]
    TransactionValidationFailed {
        inner: Box<TransactionValidation>,
        transaction_hash: Box<zksync_basic_types::H256>,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Transaction gas estimation failed in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a gas estimation for transaction failed."]
    #[doc = "This is a wrapper error that contains a more specific gas estimation error inside it, which provides details about the cause of failure."]
    TransactionGasEstimationFailed {
        inner: Box<GasEstimation>,
        transaction_data: Vec<u8>,
    } = 11u32,
    #[doc = "# Summary "]
    #[doc = "Requested block timestamp is earlier than the current timestamp."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when attempting to set a future block timestamp to a value that is earlier than the timestamp of the most recently mined block."]
    #[doc = ""]
    #[doc = "In anvil-zksync, block timestamps must always increase monotonically. This simulates the behavior of real blockchain networks where time only moves forward. Each new block must have a timestamp greater than its predecessor."]
    #[doc = ""]
    #[doc = "Anvil-zksync provides methods to manipulate time for testing purposes (like `evm_increaseTime` and `evm_setNextBlockTimestamp`), but these can only move time forward, never backward."]
    #[doc = ""]
    #[doc = "Block timestamps in anvil-zksync are used by:"]
    #[doc = "- Smart contracts that rely on `block.timestamp` for time-dependent logic"]
    #[doc = "- System contracts that need to track event timing"]
    #[doc = "- Time-locked functionality in DeFi applications and governance protocols"]
    #[doc = ""]
    #[doc = "When testing contracts that have time-dependent logic, it's important to ensure that any manipulated timestamps move forward in time, not backward."]
    TimestampBackwardsError {
        timestamp_requested: zksync_basic_types::U64,
        timestamp_now: zksync_basic_types::U64,
    } = 20u32,
    #[doc = "# Summary "]
    #[doc = "Failed to serialize transaction request into a valid transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is unable to convert a transaction request into a properly formatted transaction object."]
    #[doc = "This typically happens during transaction creation or gas estimation when the request contains invalid or incompatible parameters."]
    SerializationError {
        transaction_type: String,
        from: Box<zksync_basic_types::H256>,
        to: Box<zksync_basic_types::H256>,
        reason: String,
    } = 30u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for AnvilNode {}
impl NamedError for AnvilNode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilNodeCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilNode> for crate::ZksyncError {
    fn from(val: AnvilNode) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for AnvilNode {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilNode {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilNode::GenericError { message }
    }
}
impl From<AnvilNode> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilNode) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilNode> for crate::serialized::SerializedError {
    fn from(value: AnvilNode) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilNode {
    fn get_message(&self) -> String {
        match self {
            AnvilNode::TransactionHalt {
                inner,
                transaction_hash,
            } => {
                format ! ("[anvil_zksync-node-1] Transaction {transaction_hash} execution reverted and gas was burned:\n{inner}")
            }
            AnvilNode::TransactionValidationFailed {
                inner,
                transaction_hash,
            } => {
                format ! ("[anvil_zksync-node-10] Transaction {transaction_hash}: validation failed:\n{inner}")
            }
            AnvilNode::TransactionGasEstimationFailed {
                inner,
                transaction_data,
            } => {
                format!("[anvil_zksync-node-11] Gas estimation failed:\n{inner}")
            }
            AnvilNode::TimestampBackwardsError {
                timestamp_requested,
                timestamp_now,
            } => {
                format ! ("[anvil_zksync-node-20] Failed to force the next timestamp to value {timestamp_requested}. It should be greater than the last timestamp {timestamp_now}.")
            }
            AnvilNode::SerializationError {
                transaction_type,
                from,
                to,
                reason,
            } => {
                format ! ("[anvil_zksync-node-30] Failed to parse a {transaction_type} transaction from request (from={from}, to={to}): {reason}.")
            }
            AnvilNode::GenericError { message } => {
                format!("[anvil_zksync-node-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(GasEstimationCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum GasEstimation {
    #[doc = "# Summary "]
    #[doc = "Transaction exceeds the limit for published pubdata."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction attempts to publish more pubdata than is allowed in a batch. Each transaction has a limit on how much pubdata it can publish to maintain network efficiency and prevent abuse."]
    ExceedsLimitForPublishedPubdata {
        pubdata_published: u32,
        pubdata_limit: u32,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction gas estimation exceeds the block gas limit."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the total gas required for a transaction exceeds the maximum allowed for a block."]
    #[doc = "The total gas is calculated by summing three components: the gas needed for publishing pubdata, the fixed overhead costs,"]
    #[doc = "and the estimated gas for the transaction body itself. When this sum overflows or exceeds the block limit, this error is thrown."]
    ExceedsBlockGasLimit {
        overhead: zksync_basic_types::U64,
        gas_for_pubdata: zksync_basic_types::U64,
        estimated_body_cost: zksync_basic_types::U64,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverts and burns all gas while estimating required gas in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is trying to estimate gas required to run this transaction "]
    #[doc = "but the estimation fails because the transaction reverts and burns all gas."]
    #[doc = ""]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "If the first run was successful, anvil-zksync proceeds with the estimation"]
    #[doc = "The estimation algorithm looks for a minimum gas value that makes the transaction succeed."]
    #[doc = "This works if the transaction fails for all lower gas values and succeeds for all higher gas values."]
    #[doc = "Some valid, but exotic transactions, resist estimation."]
    #[doc = "Typically they depend on specific gas values, for example, they fail if `gasleft()` returned a value in a specific range."]
    TransactionHalt {
        inner: Box<Halt>,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverted while estimating required gas in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is trying to estimate gas required to run this transaction "]
    #[doc = "but the estimation fails because the transaction is reverted."]
    #[doc = ""]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "If the first run was successful, anvil-zksync proceeds with the estimation"]
    #[doc = "The estimation algorithm looks for a minimum gas value that makes the transaction succeed."]
    #[doc = "This works if the transaction fails for all lower gas values and succeeds for all higher gas values."]
    #[doc = "Some valid, but exotic transactions, resist estimation."]
    #[doc = "Typically they depend on specific gas values, for example, they revert if `gasleft()` returned a value in a specific range."]
    TransactionRevert {
        inner: Box<Revert>,
    } = 11u32,
    #[doc = "# Summary "]
    #[doc = "An attempt to run the transaction with maximum gas resulted in reverting the transaction and burning all gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "This error occurs when this initial run results in a revert and burns all gas, suggesting that "]
    #[doc = "no amount of gas will make this transaction executable."]
    #[doc = ""]
    #[doc = "There might be valid, but exotic transactions that fail when run with maximum gas provided,"]
    #[doc = "but these are rare. Typically they depend on specific gas values."]
    #[doc = "Usually, this error indicates either an unconditional revert or excessive gas consumption."]
    TransactionAlwaysHalts {
        inner: Box<Halt>,
    } = 20u32,
    #[doc = "# Summary "]
    #[doc = "An attempt to run the transaction with maximum gas resulted in reverting the transaction and returning unspent gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "This error occurs when this initial run results in a revert and returns unspent gas, suggesting that "]
    #[doc = "no amount of gas will make this transaction executable."]
    #[doc = ""]
    #[doc = "There might be valid, but exotic transactions that fail when run with maximum gas provided,"]
    #[doc = "but these are rare. Typically they depend on specific gas values."]
    #[doc = "Usually, this error indicates either an unconditional revert or excessive gas consumption."]
    TransactionAlwaysReverts {
        inner: Box<Revert>,
    } = 21u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for GasEstimation {}
impl NamedError for GasEstimation {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for GasEstimationCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<GasEstimation> for crate::ZksyncError {
    fn from(val: GasEstimation) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for GasEstimation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for GasEstimation {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for GasEstimation {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        GasEstimation::GenericError { message }
    }
}
impl From<GasEstimation> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: GasEstimation) -> Self {
        crate::packed::pack(value)
    }
}
impl From<GasEstimation> for crate::serialized::SerializedError {
    fn from(value: GasEstimation) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for GasEstimation {
    fn get_message(&self) -> String {
        match self {
            GasEstimation::ExceedsLimitForPublishedPubdata {
                pubdata_published,
                pubdata_limit,
            } => {
                format ! ("[anvil_zksync-gas_estim-1] Transaction has published {pubdata_published} bytes which exceeds limit for published pubdata ({pubdata_limit}).")
            }
            GasEstimation::ExceedsBlockGasLimit {
                overhead,
                gas_for_pubdata,
                estimated_body_cost,
            } => {
                format ! ("[anvil_zksync-gas_estim-2] Estimating full gas limit overflows while adding up additional gas ({gas_for_pubdata}), overhead ({overhead}), and estimated transaction body gas cost ({estimated_body_cost}).")
            }
            GasEstimation::TransactionHalt { inner } => {
                format ! ("[anvil_zksync-gas_estim-10] Gas estimation failed because the transaction exhibits exotic gas behavior and reverts, burning all gas: {inner}")
            }
            GasEstimation::TransactionRevert { inner } => {
                format ! ("[anvil_zksync-gas_estim-11] Gas estimation failed because the transaction exhibits exotic gas behavior and reverts, returning unspent gas: {inner}")
            }
            GasEstimation::TransactionAlwaysHalts { inner } => {
                format ! ("[anvil_zksync-gas_estim-20] Gas estimation is impossible because the transaction can not be executed with maximum gas, it reverts and returns unspent gas:\n{inner}")
            }
            GasEstimation::TransactionAlwaysReverts { inner } => {
                format ! ("[anvil_zksync-gas_estim-21] Gas estimation is impossible because the transaction can not be executed with maximum gas, it reverts and burns all gas:\n{inner}")
            }
            GasEstimation::GenericError { message } => {
                format!("[anvil_zksync-gas_estim-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HaltCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Halt {
    #[doc = "# Summary "]
    #[doc = "Account validation failed during execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the account validation step fails during the verification and execution of a transaction."]
    ValidationFailed {
        msg: String,
        data: String,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Paymaster validation failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the paymaster validation process fails during transaction execution."]
    PaymasterValidationFailed {
        msg: String,
        data: String,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Pre-paymaster preparation step failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs during pre-transaction paymaster preparation if the paymaster input is too short (less than 4 bytes) or its selector is unsupported."]
    PrePaymasterPreparationFailed {
        msg: String,
        data: String,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = "Payment for the transaction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system fails to deduct the required fees for executing the transaction."]
    PayForTxFailed {
        msg: String,
        data: String,
    } = 4u32,
    #[doc = "# Summary "]
    #[doc = "Failed to register factory dependencies for L1 transactions."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the system is unable to mark the factory dependencies for an L1 transaction in the known code storage. For L1 transactions, factory dependencies must be recorded as known to ensure that all required code components are available. A failure here may indicate that the dependency data is missing or malformed."]
    FailedToMarkFactoryDependencies {
        msg: String,
        data: String,
    } = 5u32,
    #[doc = "# Summary "]
    #[doc = "Transaction fee deduction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is raised when the funds transferred to the bootloader are insufficient compared to the required fee (calculated as gasLimit * gasPrice). This may occur when the payer (account or paymaster) does not send enough ETH or when fee parameters are misconfigured."]
    FailedToChargeFee {
        msg: String,
        data: String,
    } = 6u32,
    #[doc = "# Summary "]
    #[doc = "The sender address is not a valid account."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction is attempted from an address that has not been deployed as an account, meaning the `from` address is just a contract."]
    FromIsNotAnAccount = 7u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Transaction reverted due to a contract call that failed during execution."]
    InnerTxError = 8u32,
    #[doc = "# Summary "]
    #[doc = "An unknown error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system encounters an unspecified reason for reverting and burning all gas."]
    Unknown {
        msg: String,
        data: String,
    } = 9u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader encountered an unexpected state."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error can be triggered by various bootloader anomalies such as mismatched fee parameters (e.g., baseFee greater than maxFeePerGas), unaccepted pubdata price, failed system calls (like L1 messenger or System Context), or internal assertion failures."]
    UnexpectedVMBehavior {
        problem: String,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader has run out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the bootloader does not have enough gas to continue executing the transaction."]
    BootloaderOutOfGas = 11u32,
    #[doc = "# Summary "]
    #[doc = "The validation step ran out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Validation step of transaction execution exceeds the allocated gas limit."]
    ValidationOutOfGas = 12u32,
    #[doc = "# Summary "]
    #[doc = "The transaction's gas limit is excessively high."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the gas limit set for the transaction is too large for the server to handle."]
    TooBigGasLimit = 13u32,
    #[doc = "# Summary "]
    #[doc = "Insufficient gas for the bootloader to continue the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The bootloader checks if it can supply the requested gas plus overhead. If the remaining gas is below this threshold, it reverts."]
    NotEnoughGasProvided = 14u32,
    #[doc = "# Summary "]
    #[doc = "The transaction exceeded the allowed number of storage invocations."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the transaction makes too many missing invocations to memory, surpassing the allowed limit."]
    MissingInvocationLimitReached = 15u32,
    #[doc = "# Summary "]
    #[doc = "Unable to set L2 block information."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "System failed to set the necessary information for the L2 block during execution."]
    FailedToSetL2Block {
        msg: String,
    } = 16u32,
    #[doc = "# Summary "]
    #[doc = "Unable to append the transaction hash to the ongoing L2 block."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The system context call to record this transaction in the current L2 block failed."]
    FailedToAppendTransactionToL2Block {
        msg: String,
    } = 17u32,
    #[doc = "# Summary "]
    #[doc = "The virtual machine encountered a panic."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "VM experiences a critical failure and panic during transaction execution."]
    VMPanic = 18u32,
    #[doc = "# Summary "]
    #[doc = "Tracer aborted the transaction execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Custom tracer used during transaction execution decides to abort the process, typically due to specific conditions being met."]
    TracerCustom {
        msg: String,
    } = 19u32,
    #[doc = "# Summary "]
    #[doc = "Unable to publish compressed bytecodes."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Emitted when the system fails to publish the compressed bytecodes during execution."]
    FailedToPublishCompressedBytecodes = 20u32,
    #[doc = "# Summary "]
    #[doc = "Block timestamp assertion failed during the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error often occurs if the transaction's timestamp is behind the last known block or conflicts with expected chronological order."]
    FailedBlockTimestampAssertion = 21u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for Halt {}
impl NamedError for Halt {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HaltCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Halt> for crate::ZksyncError {
    fn from(val: Halt) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Halt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Halt {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Halt {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Halt::GenericError { message }
    }
}
impl From<Halt> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Halt) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Halt> for crate::serialized::SerializedError {
    fn from(value: Halt) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Halt {
    fn get_message(&self) -> String {
        match self {
            Halt::ValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-1] Account validation error: {msg}: {data}")
            }
            Halt::PaymasterValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-2] Paymaster validation error: {msg}: {data}.")
            }
            Halt::PrePaymasterPreparationFailed { msg, data } => {
                format!("[anvil_zksync-halt-3] Pre-paymaster preparation error: {msg}: {data}")
            }
            Halt::PayForTxFailed { msg, data } => {
                format!("[anvil_zksync-halt-4] Failed to pay for the transaction: {msg}: {data}")
            }
            Halt::FailedToMarkFactoryDependencies { msg, data } => {
                format!("[anvil_zksync-halt-5] Failed to mark factory dependencies: {msg}: {data}")
            }
            Halt::FailedToChargeFee { msg, data } => {
                format!("[anvil_zksync-halt-6] Failed to charge fee: {msg}: {data}")
            }
            Halt::FromIsNotAnAccount => {
                format!("[anvil_zksync-halt-7] Sender is not an account")
            }
            Halt::InnerTxError => {
                format!("[anvil_zksync-halt-8] Bootloader-based tx failed")
            }
            Halt::Unknown { msg, data } => {
                format!("[anvil_zksync-halt-9] Unknown reason: {msg}: {data}")
            }
            Halt::UnexpectedVMBehavior { problem } => {
                format ! ("[anvil_zksync-halt-10] Virtual machine entered unexpected state. Error description: {problem}")
            }
            Halt::BootloaderOutOfGas => {
                format!("[anvil_zksync-halt-11] Bootloader out of gas")
            }
            Halt::ValidationOutOfGas => {
                format!("[anvil_zksync-halt-12] Validation run out of gas")
            }
            Halt::TooBigGasLimit => {
                format ! ("[anvil_zksync-halt-13] Transaction has a too big ergs limit and will not be executed by the server")
            }
            Halt::NotEnoughGasProvided => {
                format ! ("[anvil_zksync-halt-14] Bootloader does not have enough gas to proceed with the transaction.")
            }
            Halt::MissingInvocationLimitReached => {
                format!("[anvil_zksync-halt-15] Transaction produced too much storage accesses.")
            }
            Halt::FailedToSetL2Block { msg } => {
                format!(
                    "[anvil_zksync-halt-16] Failed to set information about the L2 block: {msg}"
                )
            }
            Halt::FailedToAppendTransactionToL2Block { msg } => {
                format ! ("[anvil_zksync-halt-17] Failed to append the transaction to the current L2 block: {msg}")
            }
            Halt::VMPanic => {
                format!("[anvil_zksync-halt-18] VM panicked")
            }
            Halt::TracerCustom { msg } => {
                format!("[anvil_zksync-halt-19] Tracer aborted execution: {msg}")
            }
            Halt::FailedToPublishCompressedBytecodes => {
                format!("[anvil_zksync-halt-20] Failed to publish compressed bytecodes")
            }
            Halt::FailedBlockTimestampAssertion => {
                format!("[anvil_zksync-halt-21] Transaction failed `block.timestamp` assertion")
            }
            Halt::GenericError { message } => {
                format!("[anvil_zksync-halt-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(RevertCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Revert {
    #[doc = "# Summary "]
    #[doc = "Execution reverted due to a failure."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates that the transaction execution was reverted."]
    General {
        msg: String,
        data: Vec<u8>,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when an inner transaction within the VM fails, typically related to bootloader execution."]
    InnerTxError = 2u32,
    #[doc = "# Summary "]
    #[doc = "A generic VM error."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates a generic failure within the VM, without specific details."]
    VmError = 3u32,
    #[doc = "# Summary "]
    #[doc = "An unknown VM revert reason was encountered."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the VM encounters a revert reason that is not recognized."]
    #[doc = "In most cases, this error may also indicate that the transaction exhausted all the gas allocated for its execution."]
    Unknown {
        function_selector: String,
        data: String,
    } = 4u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for Revert {}
impl NamedError for Revert {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for RevertCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Revert> for crate::ZksyncError {
    fn from(val: Revert) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Revert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Revert {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Revert {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Revert::GenericError { message }
    }
}
impl From<Revert> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Revert) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Revert> for crate::serialized::SerializedError {
    fn from(value: Revert) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Revert {
    fn get_message(&self) -> String {
        match self {
            Revert::General { msg, data } => {
                format!("[anvil_zksync-revert-1] Execution reverted with message: {msg}")
            }
            Revert::InnerTxError => {
                format!("[anvil_zksync-revert-2] Bootloader-based transaction failed.")
            }
            Revert::VmError => {
                format!("[anvil_zksync-revert-3] VM Error")
            }
            Revert::Unknown {
                function_selector,
                data,
            } => {
                format ! ("[anvil_zksync-revert-4] Unknown VM revert reason: function_selector={function_selector}, data={data}")
            }
            Revert::GenericError { message } => {
                format!("[anvil_zksync-revert-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(StateLoaderCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum StateLoader {
    #[doc = "# Summary "]
    #[doc = "It is not allowed to load a state overriding the existing node state."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "It is not allowed to load a state overriding the existing node state. If you have a use case for that, please create an issue."]
    LoadingStateOverExistingState = 1u32,
    #[doc = "# Summary "]
    #[doc = "Attempt to load a state with no blocks"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "It is not allowed to load a state without any blocks in it."]
    LoadEmptyState = 2u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to decompress the state."]
    StateDecompression {
        details: String,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to deserialize the state file."]
    StateDeserialization {
        details: String,
    } = 4u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The version of the state file is not recognized."]
    UnknownStateVersion {
        version: u32,
    } = 5u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to access the state file."]
    StateFileAccess {
        path: String,
        reason: String,
    } = 6u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for StateLoader {}
impl NamedError for StateLoader {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for StateLoaderCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<StateLoader> for crate::ZksyncError {
    fn from(val: StateLoader) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for StateLoader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for StateLoader {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for StateLoader {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        StateLoader::GenericError { message }
    }
}
impl From<StateLoader> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: StateLoader) -> Self {
        crate::packed::pack(value)
    }
}
impl From<StateLoader> for crate::serialized::SerializedError {
    fn from(value: StateLoader) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for StateLoader {
    fn get_message(&self) -> String {
        match self {
            StateLoader::LoadingStateOverExistingState => {
                format ! ("[anvil_zksync-state-1] Loading state into a node with existing state is not allowed.")
            }
            StateLoader::LoadEmptyState => {
                format!("[anvil_zksync-state-2] Loading a state without blocks is not allowed.")
            }
            StateLoader::StateDecompression { details } => {
                format!("[anvil_zksync-state-3] Failed to decompress state: {details}.")
            }
            StateLoader::StateDeserialization { details } => {
                format!("[anvil_zksync-state-4] Failed to deserialize state: {details}")
            }
            StateLoader::UnknownStateVersion { version } => {
                format!("[anvil_zksync-state-5] Unknown version of the state: {version}.")
            }
            StateLoader::StateFileAccess { path, reason } => {
                format ! ("[anvil_zksync-state-6] Error while accessing the state located at `{path}`: {reason}.")
            }
            StateLoader::GenericError { message } => {
                format!("[anvil_zksync-state-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(TransactionValidationCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum TransactionValidation {
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed due to excessive gas limit -- did you provide invalid gas limit?"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's gas limit exceeds the maximum allowed gas allowed by ZKsync protocol."]
    #[doc = "As of protocol version 27, the gas is limited to 2^50"]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    InvalidGasLimit {
        tx_gas_limit: Box<zksync_basic_types::U256>,
        max_gas: Box<zksync_basic_types::U256>,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed due to excessive gas per pubdata limit."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's gas per pubdata limit exceeds the maximum allowed gas allowed by ZKsync protocol."]
    #[doc = "As of protocol version 27, the gas is limited to 2^50"]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    GasPerPubdataLimit {
        tx_gas_per_pubdata_limit: Box<zksync_basic_types::U256>,
        max_gas: Box<zksync_basic_types::U256>,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Transaction's maxFeePerGas is lower than the current gas price in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the maximum fee per gas specified in the transaction is lower than the current gas price set in the anvil-zksync node."]
    #[doc = "To be considered valid, transactions must specify a maxFeePerGas that is greater or equal to the current gas price"]
    #[doc = ""]
    #[doc = "In anvil-zksync, the gas price can be configured when starting the node using `--l1-gas-price` argument or can be modified dynamically. By default, the node simulates a gas price model similar to the real ZKSync network, including:"]
    #[doc = "1. A base computation fee (similar to Ethereum's base fee)"]
    #[doc = "2. A simulated pubdata posting fee"]
    #[doc = ""]
    #[doc = "Even though anvil-zksync is a testing environment, it enforces these gas price validations to ensure that your tests accurately reflect how transactions would behave on the actual ZKSync network."]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    MaxFeePerGasTooLow {
        max_fee_per_gas: Box<zksync_basic_types::U256>,
        l2_gas_price: Box<zksync_basic_types::U256>,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = "Transaction's maxPriorityFeePerGas exceeds maxFeePerGas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's maximum priority fee per gas is greater than its maximum fee per gas in anvil-zksync."]
    #[doc = "In ZKSync, the field `maxPriorityFeePerGas` is ignored, as ZKsync doesnâ€™t have a concept of priority fees."]
    #[doc = "Instead, `maxFeePerGas` is utilized and includes the base fees."]
    #[doc = "However, certain transaction types like EIP-1559 or EIP-712 may contain field `maxPriorityFeePerGas`, which should be less or equal to the field `maxFeePerGas`."]
    MaxPriorityFeeGreaterThanMaxFee {
        max_fee_per_gas: Box<zksync_basic_types::U256>,
        max_priority_fee_per_gas: Box<zksync_basic_types::U256>,
    } = 4u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for TransactionValidation {}
impl NamedError for TransactionValidation {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for TransactionValidationCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<TransactionValidation> for crate::ZksyncError {
    fn from(val: TransactionValidation) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for TransactionValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for TransactionValidation {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for TransactionValidation {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        TransactionValidation::GenericError { message }
    }
}
impl From<TransactionValidation>
    for crate::packed::PackedError<crate::error::domains::ZksyncError>
{
    fn from(value: TransactionValidation) -> Self {
        crate::packed::pack(value)
    }
}
impl From<TransactionValidation> for crate::serialized::SerializedError {
    fn from(value: TransactionValidation) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for TransactionValidation {
    fn get_message(&self) -> String {
        match self {
            TransactionValidation::InvalidGasLimit {
                tx_gas_limit,
                max_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-1] Gas limit for transaction is {tx_gas_limit} which exceeds maximum allowed gas {max_gas}")
            }
            TransactionValidation::GasPerPubdataLimit {
                tx_gas_per_pubdata_limit,
                max_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-2] Gas per pubdata limit is {tx_gas_per_pubdata_limit} which exceeds maximum allowed gas {max_gas}")
            }
            TransactionValidation::MaxFeePerGasTooLow {
                max_fee_per_gas,
                l2_gas_price,
            } => {
                format ! ("[anvil_zksync-tx_invalid-3] Max fee per gas: {max_fee_per_gas}, current L2 gas price {l2_gas_price} is too expensive.")
            }
            TransactionValidation::MaxPriorityFeeGreaterThanMaxFee {
                max_fee_per_gas,
                max_priority_fee_per_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-4] maxPriorityFeePerGas={max_priority_fee_per_gas} exceeds the limit value maxFeePerGas={max_fee_per_gas}")
            }
            TransactionValidation::GenericError { message } => {
                format!("[anvil_zksync-tx_invalid-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for Ethereum VM (EVM)."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_EVM {}
impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}
impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
            LLVM_EVM::GenericError { message } => {
                format!("[compiler-llvm+evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_Era {}
impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}
impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
            LLVM_Era::GenericError { message } => {
                format!("[compiler-llvm+era-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the official Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Solc {}
impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Solc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}
impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
            Solc::GenericError { message } => {
                format!("[compiler-solc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync fork of Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for SolcFork {}
impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for SolcFork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}
impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}
impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
            SolcFork::GenericError { message } => {
                format!("[compiler-solc+fork-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Solidity compiler for EraVM and EVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zksolc {}
impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zksolc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}
impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
            Zksolc::GenericError { message } => {
                format!("[compiler-zksolc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Vyper compiler for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zkvyper {}
impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}
impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
            Zkvyper::GenericError { message } => {
                format!("[compiler-zkvyper-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the web3 API."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for API {}
impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for API {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}
impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}
impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
            API::GenericError { message } => {
                format!("[core-api-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in EraVM virtual machine executing contracts."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for EraVM {}
impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for EraVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}
impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
            EraVM::GenericError { message } => {
                format!("[core-eravm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the contract execution environment, bootloader, etc."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for ExecutionPlatform {}
impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}
impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}
impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
            ExecutionPlatform::GenericError { message } => {
                format!("[core-exec-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the sequencer node"]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
    GenericSequencerError { message: String } = 1u32,
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Sequencer {}
impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Sequencer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}
impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
            Sequencer::GenericSequencerError { message } => {
                format!("[core-seq-1] Generic error: {message}")
            }
            Sequencer::GenericError { message } => {
                format!("[core-seq-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Foundry implementation."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryUpstream {}
impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}
impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
            FoundryUpstream::GenericError { message } => {
                format!("[foundry-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for Foundry."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryZksync {}
impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}
impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
            FoundryZksync::GenericError { message } => {
                format!("[foundry-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Hardhat implementation."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatUpstream {}
impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}
impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
            HardhatUpstream::GenericError { message } => {
                format!("[hardhat-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for HardHat."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatZksync {}
impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.get_message())
    }
}
impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}
impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
            HardhatZksync::GenericError { message } => {
                format!("[hardhat-zksync-0] Generic error: {message}")
            }
        }
    }
}
